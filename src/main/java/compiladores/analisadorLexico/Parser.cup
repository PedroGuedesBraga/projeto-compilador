package compiladores.analisadorLexico;

import java_cup.runtime.*;
import java.util.*;
import java.io.*;

action code {:
 Hashtable<String, String> type = new Hashtable();
 Hashtable value = new Hashtable();
 
 
 
:};



parser code {:

  class Exp {
	    public String type;
	    public String code;
	    

	    public Exp(String t, String code) {
  		  this.type = t;
  		  this.code = code;
	    }
	  
	}


    public void report_error(String message, Object info)  {
        System.out.println("Warning - " + message);
    }

    public void report_fatal_error(String message, Object info)  {
        System.out.println("Error - " + message);
        System.exit(-1);
    }
    
    public void syntax_error(Symbol s){
    System.out.println("compiler has detected a syntax error at line " + s.left 
        + " column " + s.right + " symbol id: " + s.sym);
	}
	
	public boolean typeCheckAritimetico(String op , Exp e1 , Exp e2){
			
			if(e1.type.equals(e2.type)){
				if(e1.type.equals("integer")){
				 return true;}
				if(e1.type.equals("string")) {
					if(op.equals("+")){
						return true;
					}
					else{return false;}
				}
				else{return false;}
				
			}
			else{
			 return false;
			}
	}
	
	public boolean typeCheckRelacional(String op , Exp e1 , Exp e2){
		if(op == "=" || op == "<>"){
			return true;
		}
		if(e1.type.equals(e2.type)){
			return true;
		}
		else{
			return false;
		}
	}

:};



terminal PROGRAM, BEGIN, END, ASSIGNMENT, COMMA, DOT,
SEMICOLON, COLON, OPEN_PARENTHESES, CLOSE_PARENTHESES, OPEN_BRACKETS, CLOSE_BRACKETS, OPEN_CURLY_BRACKETS,
CLOSE_CURLY_BRACKETS, CRASIS, AND, ARRAY, CASE, CONST, INTEGER_DIV, DO, DOWNTO, ELSE, FILE, FOR,
FUNCTION, GOTO, IF, IN, LABEL, MOD, NIL, NOT, OF, OR, PACKED, PROCEDURE, RECORD, REPEAT, SET,
THEN, TO, TYPE, UNTIL, VAR, WHILE, WITH, TYPE_INTEGER, REAL;
terminal String STRING_LITERAL;
terminal String IDENTIFIER;
terminal String INTEGER;
terminal String TRUE;
terminal String FALSE;
terminal String STRING;
terminal String BOOLEAN;
terminal String GT;
terminal String UQ;
terminal String GE;
terminal String EQ;
terminal String LE;
terminal String LT;

terminal String PLUS;
terminal String MINUS;
terminal String MULT;
terminal String DIV;




non terminal program, declarations, type_declaration, constant_declaration1, variable_declaration, number, 
procedure_declaration_without_parenthesis, procedure_declaration_with_parenthesis, procedure_arguments, procedure_arguments_aux, 
arguments1, arguments2, procedure_declaration, optional_semicolon, list_of_identifiers, optional_var,
function_declaration_without_parenthesis, function_declaration_with_parenthesis, function_declaration, 
function_arguments, function_declaration_aux, function_local_declarations,assignment_declaration, program_block;
non terminal Exp expression_declaration;
non terminal String op_aritimetical_declaration;
non terminal String op_relational_declaration;
non terminal Exp term_declaration;




/*---------------------------------------------------------- INICIO ----------------------------------------*/


start with program;


program ::= PROGRAM IDENTIFIER SEMICOLON declarations BEGIN program_block END DOT;

declarations ::= declarations constant_declaration1 
				 | 
				 declarations variable_declaration
				 |
				 declarations procedure_declaration BEGIN END SEMICOLON 
				 |
				 declarations function_declaration
				 | 
				 
				 ; 
				 
program_block ::= program_block assignment_declaration 
				  |
				  
				  ;



/*------------------------------------PROCEDURES------------------------------------------------------------------*/	

			
			
							
				/* PROCEDURES - BASEADO EM: https://www.tutorialspoint.com/pascal/pascal_procedures.htm */
				
procedure_declaration ::=  procedure_declaration_without_parenthesis SEMICOLON
						  |
						   procedure_declaration_with_parenthesis SEMICOLON
						  ;

/*Declaracao de procedures sem parenteses*/
procedure_declaration_without_parenthesis ::= PROCEDURE IDENTIFIER;

/*Declaracao de procedures com parenteses (pode ter nenhum ou varios argumentos) */
procedure_declaration_with_parenthesis ::= PROCEDURE IDENTIFIER OPEN_PARENTHESES procedure_arguments CLOSE_PARENTHESES;


				

/* Argumentos de uma procedure na forma de declarar um argumento ou varios argumentos de uma vez: "declaracao1, declaracao2 : TIPO"  */

procedure_arguments ::= arguments1 | arguments2;

arguments1 ::= optional_var list_of_identifiers SEMICOLON arguments1 
			   | 
			   optional_var list_of_identifiers
			   ;
			   
arguments2 ::= ;
					  
list_of_identifiers ::= IDENTIFIER:id COMMA list_of_identifiers:tipo {:  if(!type.containsKey(id)){
																			type.put(id, (String) tipo);
																	 		RESULT = tipo;
																	 }else{
																	 		report_fatal_error("Variavel ja foi declarada: " + id, id);	
																	 } :}
						| 
						IDENTIFIER:id COLON type_declaration:tipo {: if(!type.containsKey(id)){
																			type.put(id, (String) tipo);
																	 		RESULT = tipo;
																	 }else{
																	 		report_fatal_error("Variavel ja foi declarada: " + id, id);	
																	 } :};
						
optional_var ::= VAR | ;
				

/*----------------------------------------------------------------------------------------------*/

							/*CONSTANTES - Not working yet - APARENTEMENTE N PRECISA*/
constant_declaration1 ::= CONST IDENTIFIER EQ number SEMICOLON;





/*--------------------------DECLARACAO DE VARIAVEIS--------------------------------------------------------*/

							
variable_declaration ::= optional_var list_of_identifiers SEMICOLON;


/*---------------------------DECLARACAO DE TIPOS-------------------------------------------------------------*/
type_declaration ::= TYPE_INTEGER {:RESULT = "integer";:}
					 | 
					 BOOLEAN {:RESULT = "boolean";:}
					 | 
					 STRING {:RESULT = "string";:}
					 ;

							/*NUMEROS*/			 
number ::= INTEGER DOT INTEGER 
		   | 
		   INTEGER
		   ;
		   
/*----------------------------------------DECLARACAO DE FUNCOES---------------------------------------------------*/
function_declaration ::= function_declaration_aux function_local_declarations BEGIN END SEMICOLON;

function_declaration_aux ::= function_declaration_without_parenthesis 
						 | 
						 function_declaration_with_parenthesis;

function_declaration_without_parenthesis ::= FUNCTION IDENTIFIER COLON type_declaration SEMICOLON;

function_declaration_with_parenthesis ::= FUNCTION IDENTIFIER OPEN_PARENTHESES function_arguments
CLOSE_PARENTHESES COLON type_declaration SEMICOLON;

								/* (Aproveita producoes de procedures) */
function_arguments ::= arguments1 | arguments2;	

function_local_declarations ::= variable_declaration function_local_declarations | ;							



/*------------------------------------------DECLARACAO DE EXPRESSOES------------------------------------------------*/

expression_declaration ::=  expression_declaration:e1 op_relational_declaration:op term_declaration:e2 
							{:if(typeCheckRelacional(op ,e1 , e2)){
								Exp e = new Exp("Boolean",e1.code+op+e2.code);
								RESULT = e;
							}
							else{report_fatal_error("Não se pode operar " + e1.type+ " com "+e2.code, e1);}
							:}
						   |expression_declaration:e1 op_aritimetical_declaration:op term_declaration:e2
						   {:if(typeCheckAritimetico(op ,e1 ,e2)){
						   		Exp e = new Exp(e1.type,e1.code+op+e2.code);
						   		RESULT = e;
						   }
						   else {
						    report_fatal_error("Não se pode operar " + e1.type+":"+e1.code+ " com "+e2.type+":"+e2.code, e1);
						   }:}
						   |term_declaration:e1 {:RESULT = e1;:};


op_relational_declaration ::= EQ {:RESULT = "=";:} 
							  | GE {:RESULT = ">=";:}
							  | LE  {:RESULT = "<=";:}
							  | GT  {:RESULT = ">";:}
							  | LT  {:RESULT = "<";:}
							  | UQ {:RESULT = "<>";:};
							  
op_aritimetical_declaration ::= PLUS {:RESULT = "+";:}
								| MINUS {:RESULT = "-";:}
								| MULT {:RESULT = "*";:}
								| DIV {:RESULT = "/";:};


term_declaration ::= OPEN_PARENTHESES expression_declaration:e1 CLOSE_PARENTHESES  {:RESULT = e1;:}
					 | INTEGER:i {:Exp e = new Exp("integer",i);
					 RESULT = e;:}
					 | IDENTIFIER:id {:Exp e = new Exp(type.get(id),id);
					 RESULT = e;:}
					 | TRUE:t  {:Exp e = new Exp("Boolean",t);
					 RESULT = e;:}
					 | FALSE:f {:Exp e = new Exp("Boolean",f);
					 RESULT = e;:}
					 | STRING_LITERAL:s{:Exp e = new Exp("string",s);
					 RESULT = e;:};

/*------------------------------------------DECLARACAO DE ATRIBUICAO------------------------------------------------*/

assignment_declaration ::= IDENTIFIER:id ASSIGNMENT expression_declaration:e SEMICOLON{:
	if(type.get(id) != null){
		if(type.get(id).equals(e.type)){
				value.put(id,e.code);
		}
		
		else{ report_fatal_error("O tipo " + type.get(id) + " não pode ser associado ao tipo " +e.type, id); }
		
	}
	
	else {
	report_fatal_error("Variavel nao foi declarada anteriormente " + id, id);
	}
	
	
:};

/*------------------------------------------DECLARACAO DE SETS------------------------------------------------*/




